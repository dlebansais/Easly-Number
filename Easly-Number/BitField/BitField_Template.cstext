[assembly: System.Runtime.CompilerServices.InternalsVisibleToAttribute("Test-Easly-Number")]

namespace EaslyNumber
{
    using System;
    using System.Diagnostics;

    internal class BitField_Template
    {
        #region Init
        /// <summary>
        /// Initializes a new instance of the <see cref="BitField_Template"/> class.
        /// </summary>
        public BitField_Template()
        {
            Content = new Template[0];
            SignificantBits = 0;
            ShiftBits = 0;

            Debug.Assert(LastItemIndex < 0);
        }
        #endregion

        #region Properties
        /// <summary>
        /// Number of significant bits in the field.
        /// </summary>
        public long SignificantBits { get; protected set; }

        /// <summary>
        /// Number of unstored bits to the right of significant bits.
        /// </summary>
        public long ShiftBits { get; protected set; }

        /// <summary>
        /// True if the bit field represents value zero.
        /// </summary>
        public bool IsZero
        {
            get { return SignificantBits == 1 && Content[0] == 0; }
        }
        #endregion

        #region Client Interface
        /// <summary>
        /// Sets the object to represent zero.
        /// </summary>
        public void SetZero()
        {
            Content = new Template[1];
            Content[0] = 0;
            SignificantBits = 1;
            ShiftBits = 0;

            Debug.Assert(LastItemIndex == 0);
        }

        /// <summary>
        /// Decreases the precision of the bit field by shifting bits to the right.
        /// </summary>
        public void DecreasePrecision()
        {
            int shiftValue = 1;

            Debug.Assert(SignificantBits >= shiftValue);

            long Carry = 0;
            long LastIndex = LastItemIndex;
            int CarryShift = (sizeof(Template) * 8) - shiftValue;

            Debug.Assert(LastIndex >= 0 && LastIndex < Content.Length);

            for (long i = LastIndex + 1; i > 0; i--)
            {
                long ElementValue = Content[i - 1];
                long NextCarry = (Template)(ElementValue << CarryShift);

                ElementValue >>= shiftValue;
                ElementValue += Carry;
                Content[i - 1] = (Template)ElementValue;

                Carry = NextCarry;
            }

            SignificantBits -= shiftValue;
            ShiftBits += shiftValue;

            // The value of LastItemIndex is recalculated with the updated value of SignificantBits.
            if (LastIndex > LastItemIndex)
            {
                Debug.Assert(Content[LastIndex] == 0);

                Array.Resize(ref Content, Content.Length - 1);
            }
        }

        /// <summary>
        /// Gets the value of the bit at position <paramref name="position"/>.
        /// </summary>
        /// <param name="position">Position of the bit to get.</param>
        public bool GetBit(long position)
        {
            Debug.Assert(position >= 0 && position < ShiftBits + SignificantBits);

            if (position < ShiftBits)
                return false;

            position -= ShiftBits;

            Debug.Assert(position >= 0 && position < SignificantBits);

            long Index = ItemIndex(position);
            int Offset = ItemOffset(position);

            Template Mask = (Template)(1UL << Offset);
            return (Content[Index] & Mask) != 0;
        }

        /// <summary>
        /// Sets the bit at position <paramref name="position"/>.
        /// </summary>
        /// <param name="position">Position of the bit to get.</param>
        /// <param name="value">The new value.</param>
        public void SetBit(long position, bool value)
        {
            position -= ShiftBits;

            Debug.Assert(position >= 0 && position <= SignificantBits);

            long Index = ItemIndex(position);
            int Offset = ItemOffset(position);

            if (position >= SignificantBits)
            {
                if (Index >= Content.Length)
                {
                    Array.Resize(ref Content, (int)(Index + 1));
                }

                SignificantBits = position + 1;
            }

            if (value)
            {
                Template Mask = (Template)(1UL << Offset);
                Content[Index] |= Mask;
            }
        }

        public BitField_Template Clone()
        {
            BitField_Template Result = Create();

            Template[] ContentClone = new Template[Content.Length];
            Array.Copy(Content, ContentClone, Content.Length);

            Result.Content = ContentClone;
            Result.SignificantBits = SignificantBits;
            Result.ShiftBits = ShiftBits;

            return Result;
        }
        #endregion

        #region Comparison Operations
        /// <summary>
        /// Checks if two bit fields are equal.
        /// </summary>
        /// <param name="other">The other instance.</param>
        public bool IsEqual(BitField_Template other)
        {
            if (SignificantBits != other.SignificantBits || ShiftBits != other.ShiftBits)
                return false;
            if (SignificantBits == 0)
                return true;

            Debug.Assert(SignificantBits > 0);
            long LastIndex = LastItemIndex;
            Debug.Assert(LastIndex >= 0 && LastIndex < Content.Length);

            for (long i = 0; i <= LastIndex; i++)
                if (Content[i] != other.Content[i])
                    return false;

            return true;
        }

        /// <summary>
        /// Checks if <paramref name="x"/> is lesser than <paramref name="y"/>.
        /// </summary>
        /// <param name="x">The first bit field.</param>
        /// <param name="y">The second bit field.</param>
        public static bool operator <(BitField_Template x, BitField_Template y)
        {
            long PositionX = x.HighestBitSet;
            long PositionY = y.HighestBitSet;

            if (PositionX >= 0 && PositionY >= 0)
            {
                if (PositionX != PositionY)
                    return PositionX < PositionY;

                long Position = PositionX;
                Debug.Assert(Position == PositionY);

                return IsContentLesser(x, y, Position);
            }
            else if (PositionX < 0 && PositionY >= 0)
                return true;
            else if (PositionX >= 0 && PositionY < 0)
                return false;
            else
                return false;
        }

        /// <summary>
        /// Checks if the content of <paramref name="x"/> is lesser than the content of <paramref name="y"/>.
        /// </summary>
        /// <param name="x">The first bit field.</param>
        /// <param name="y">The second bit field.</param>
        /// <param name="position">The bit position where to start comparing.</param>
        private static bool IsContentLesser(BitField_Template x, BitField_Template y, long position)
        {
            Debug.Assert(position >= x.ShiftBits && position < x.ShiftBits + x.SignificantBits && position >= y.ShiftBits && position < y.ShiftBits + y.SignificantBits);
            Debug.Assert(x.GetBit(position));
            Debug.Assert(y.GetBit(position));

            long LowestPosition = x.ShiftBits <= y.ShiftBits ? x.ShiftBits : y.ShiftBits;

            bool BitX, BitY;
            do
            {
                position--;
                BitX = x.GetBit(position);
                BitY = y.GetBit(position);
            }
            while (BitX == BitY && position > LowestPosition);

            if (!BitX && BitY)
                return true;
            else if (BitX && !BitY)
                return false;
            else
            {
                Debug.Assert(position <= LowestPosition);
                return false;
            }
        }

        /// <summary>
        /// Checks if <paramref name="x"/> is greater than <paramref name="y"/>.
        /// </summary>
        /// <param name="x">The first bit field.</param>
        /// <param name="y">The second bit field.</param>
        public static bool operator >(BitField_Template x, BitField_Template y)
        {
            return y < x;
        }

        /// <summary>
        /// Return the position of the highest bit set, -1 if none.
        /// </summary>
        private long HighestBitSet
        {
            get
            {
                if (SignificantBits > 0)
                {
                    long LastIndex = LastItemIndex;
                    Debug.Assert(LastIndex >= 0 && LastIndex < Content.Length);

                    for (long i = LastIndex; i >= 0; i--)
                    {
                        long ElementValue = Content[i];

                        if (ElementValue != 0)
                        {
                            int j = 0;
                            do
                            {
                                ElementValue >>= 1;
                                j++;
                            }
                            while (ElementValue != 0);

                            return (i * sizeof(Template) * 8) + j - 1 + ShiftBits;
                        }
                    }
                }

                return -1;
            }
        }
        #endregion

        #region Implementation
        /// <summary>
        /// Creates a new BitField_Template object.
        /// </summary>
        protected virtual BitField_Template Create()
        {
            return new BitField_Template();
        }

        /// <summary>
        /// Index of the last item in <see cref="Content"/>.
        /// Returns -1 if no items.
        /// </summary>
        private long LastItemIndex
        {
            get { return ItemIndex(SignificantBits + (sizeof(Template) * 8) - 1) - 1; }
        }

        /// <summary>
        /// Index of an item specified by its bit position.
        /// </summary>
        /// <param name="position">The bit position.</param>
        /// <returns>The corresponding item index in <see cref="Content"/>.</returns>
        private long ItemIndex(long position)
        {
            return position / (sizeof(Template) * 8);
        }

        /// <summary>
        /// Offset of a bit in the item specified by its position.
        /// </summary>
        /// <param name="position">The bit position.</param>
        /// <returns>The corresponding offset in the <see cref="Content"/> item.</returns>
        private int ItemOffset(long position)
        {
            return (int)(position % (sizeof(Template) * 8));
        }

        /// <summary>
        /// The bit field data.
        /// </summary>
        private Template[] Content;
        #endregion
    }
}
